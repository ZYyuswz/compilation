#  作业题目6：重写溢出中断服务程序

##  一、实验目的

深入理解标志寄存器的工作原理，特别是溢出标志(OF)和进位标志(CF)的区别
掌握x86架构中断处理机制，特别是INTO中断(4号中断)的工作原理
学习在C语言中使用内联汇编进行底层硬件操作
理解有符号数溢出的危害及检测方法
掌握中断服务程序的编写和安装方法

##  二、实验原理

### 2.1 标志寄存器(EFLAGS)
溢出标志(OF)：有符号数运算结果超出表示范围时置1
进位标志(CF)：无符号数运算产生进位/借位时置1
重要区别：同一运算会同时设置OF和CF，程序根据数据类型选择关注哪个标志

2.2 INTO中断机制
asm

复制

下载
ADD/SUB/IMUL  ; 算术运算指令
INTO          ; 检查OF标志，若OF=1则触发4号中断
2.3 中断向量表
4号中断专门用于溢出处理

中断向量表存储在内存最低的1KB空间

每个中断向量占4字节(段地址:偏移地址)

2.4 C语言内联汇编
在C程序中嵌入汇编代码，直接操作硬件资源。

三、实验环境
操作系统：DOS环境(DOSBox模拟器)

编译器：Turbo C++ 3.0 / Borland C++ 3.1

编程语言：C语言 + 内联汇编

目标平台：x86架构

四、实验内容与实现
4.1 核心代码实现
4.1.1 中断服务程序
c

复制

下载
void interrupt new_overflow_isr(void)
{
    overflow_detected = 1;
    sprintf(error_message, "算术溢出错误：有符号数运算结果超出表示范围");
    printf("\n*** 溢出中断被触发！ ***\n");
    printf("错误信息: %s\n", error_message);
}
4.1.2 安全运算函数
c

复制

下载
int safe_signed_add(int a, int b)
{
    int result;
    overflow_detected = 0;
    
    asm {
        mov eax, a
        add eax, b      ; 执行加法，设置OF标志
        into            ; 检查溢出并触发中断
        mov result, eax
    }
    
    return result;
}
4.1.3 中断向量操作
c

复制

下载
// 安装中断处理程序
void install_overflow_handler(void)
{
    original_overflow_isr = _dos_getvect(4);  // 保存原向量
    _dos_setvect(4, new_overflow_isr);        // 设置新向量
}
4.2 程序结构
text

复制

下载
主程序
    │
    ├── 安装中断处理程序
    │
    ├── 自动测试模式
    │   ├── 正溢出测试(INT_MAX + 1)
    │   ├── 负溢出测试(INT_MIN - 1)
    │   └── 乘法溢出测试
    │
    ├── 交互测试模式
    │
    ├── C语言溢出行为演示
    │
    └── 恢复原中断程序
五、实验结果与分析
5.1 测试结果
测试用例1：正溢出
text

复制

下载
测试 1: INT_MAX + 1 (正溢出)
操作: 2147483647 + 1

*** 溢出中断被触发！ ***
错误信息: 算术溢出错误：有符号数运算结果超出表示范围
结果: 检测到溢出！实际结果: -2147483648 (不可信)
分析：正数溢出后变为负数，验证了二进制补码表示的特性。

测试用例2：负溢出
text

复制

下载
测试 2: INT_MIN + (-1) (负溢出)
操作: -2147483648 + -1

*** 溢出中断被触发！ ***
结果: 检测到溢出！实际结果: 2147483647 (不可信)
分析：负数溢出后变为正数，同样符合补码运算规则。

测试用例3：正常运算
text

复制

下载
测试 6: 正常加法测试
操作: 100 + 200
结果: 300 (正常)
分析：正常运算不会触发中断，程序正确执行。

5.2 性能对比
检测方式	代码复杂度	执行效率	可靠性
JO/JNO指令	简单	高	需要手动检查
INTO中断	复杂	中等	自动触发，可靠性高
C语言默认	无	最高	无检测，危险性大
六、关键技术难点与解决方案
6.1 难点分析
中断服务程序编写：需要正确处理寄存器保存和恢复

内联汇编语法：不同编译器的内联汇编语法差异

中断向量操作：需要准确获取和设置中断向量

全局变量通信：中断服务程序与主程序间的数据传递

6.2 解决方案
使用interrupt关键字让编译器自动处理寄存器

采用Turbo C内联汇编语法，确保兼容性

使用_dos_getvect()和_dos_setvect()标准函数

通过全局变量overflow_detected进行状态通信

七、实验总结
7.1 实验成果
✅ 成功重写了4号中断服务程序

✅ 实现了基于INTO指令的溢出检测机制

✅ 提供了多种安全运算函数

✅ 完成了全面的测试验证

✅ 对比展示了C语言默认溢出行为的危险性

7.2 技术收获
深入理解了x86中断处理机制

掌握了内联汇编编程技巧

学会了中断向量的操作方法

加深了对有符号数溢出的认识

7.3 实际意义
本实验实现的溢出检测机制可以应用于：

金融计算系统

科学计算软件

嵌入式系统

任何对数值精度要求高的场景

7.4 改进方向
支持更多数据类型(long long, float等)

添加更详细的错误信息(发生溢出的具体地址)

实现更优雅的错误恢复机制

支持多线程环境下的中断处理
